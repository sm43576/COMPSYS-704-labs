Controller(
		input signal bottleAtPos1, bottleAtPos5;
		input Boolean channel conveyorReq;
		output signal motConveyorOnOff;
		output String channel conveyorStatus;
		)
->{

	while(true) {
	
	//	System.out.println("Hello World!");
	//Wait until bottle at position 5 hasn't left yet
		receive conveyorReq; // send a request everytime bottle on the conveyor belt.
		
		Boolean req = (Boolean) #conveyorReq;
		System.out.println("received?");
		System.out.println(req);
		
		if(req) { //bottle has entered from left side.
			send conveyorStatus("busy");
		
			System.out.println("conveyor busy");
			//await(bottleAtPos5);
		//	System.out.println("bottle at pos 5 hasn't left yet");
			pause;
	
			//bottle at pos1
			abort(bottleAtPos1 && !bottleAtPos5) {//cant abort before it let the turntable rotate with bottle at pos5.
				present(!bottleAtPos1){ //when bottle is not at position 1
					System.out.println("Motor is on"); 
				//	{sustain motConveyorOnOff} || {sustain MotorPos1On};    REPLACE
					sustain motConveyorOnOff && MotorPos1On;  // keep motor on
	
				}
			}
		
			System.out.println("Motor is off");
			send conveyorStatus("done");
			System.out.println("conveyor done");
			pause;
		}else {  //handle if bottleatPOs5 and nobottle on conveyor near pos1. 
			// if ( statement)

			//bottle hasnt been placed on the conveyor but if there is bottleatpos5
			//abort(!bottleAtpos1 && bottleLeftPos5)
//			{
//				//{sustain motConveyorOnOff} || {sustain MotorPos5On};    REPLACE
//			}
//			
			//, else do nothing.
			System.out.println("conveyor idling");
			send conveyorStatus("idle");
		}
		pause;
	}
}


RotaryTable(
        input signal tableAlignedWithSensor, capOnBottleAtPos1, RTbottleAtPos1;
        input Boolean channel allOperationsFinished; // From Orchestrator
        output signal rotaryTableTrigger; // To Plant
        output Boolean channel rotaryStatus; // To Orchestrator 
        )
->{
    signal allOperationsFinished;
    while(true) {
        System.out.println("HELLLLLLLLO");
        
        // wait until it receives an OK from orchestrator
        await(allOperationsFinished);
        System.out.println("RECIEVED orchestrator task");
        pause;
        
//        await(RTbottleAtPos1);
//        System.out.println("A bottle is at position 1");
//        pause;
        // TODO:DELETE
        // wait until there is no cap on the bottle at position 1 (i.e.) bottle is removed
        await(!capOnBottleAtPos1);
        System.out.println("A cap bottle is NOT on the bottle at pos 1");
        pause;
        
        
        // when the rotoray table is aligned with sensor stop sustaining the trigger
        abort(tableAlignedWithSensor){
            System.out.println("emitting rotary trigger");
//            emit rotaryTableTrigger;
        }
//        emit rotaryStatus("done");
        pause;
        System.out.println("out - next loop");
        
    }
//    ||
//    {
//       while(true) {
//    	   // Send idling status to orchestrator.
//	        abort(!allOperationsFinished){
//	            loop{
//	            	System.out.println("idling...");
//	            	send rotaryStatus("idle");
//	            	pause;
//	            }
//	        }
//       }
//    }
 
}

LiquidFiller(
		input Boolean channel fillerReq;
		input int[] channel percentLiquid;
		input signal bottleAtPos2,dosUnitEvac,dosUnitFilled;
		input Integer signal selectedCanister;
		
		output signal valveInjectorOnOff,valveInletOnOff,dosUnitValveRetract,dosUnitValveExtend;
		output Integer signal selectCanister,receivedPercentage;	
		output String channel fillerStatus;
		)
->{
	
	while(true) {
		receive fillerReq;
		Boolean request = #fillerReq;// polling the system if its busy or not. 
		
		if(request) {
				// No bottle at position 2 then send idle status
				present(!bottleAtPos2){
					send fillerStatus("idle");
				}
			
				// bottle IS at position 2 then do filler work
				present(bottleAtPos2){
					send fillerStatus("busy");
					receive percentLiquid;
	
					int[] recPercentLiq = (int[])#percentLiquid; // [32,43,22,3]  += 100%				
					int canisterNum = 1;	// reset, select first canister.
					
					while(canisterNum<5) {

						//Select Canister
						abort(selectedCanister){//wait till canister selected
						 	sustain selectCanister(canisterNum);  // send the selected canisterNUm we want.
						}
					
						//Brings canister to the top
						 abort(!dosUnitEvac){ 
								{sustain dosUnitValveRetract;} || {sustain valveInjectorOnOff;}
						 }
						 System.out.println("Canister above bottle");
					
						  
						 //Send percentage
						 emit receivedPercentage(recPercentLiq[canisterNum-1]);// send percentage want to befilled
						 
						 //Receive Percentage filled, check signal
						 abort(dosUnitFilled){ // close valve once filled
							 sustain valveInletOnOff; 
						 }
						 
						 System.out.println("Bottle controller filled");
						 
						 abort(dosUnitEvac){// bring cylinder to the bottom
							 {sustain dosUnitValveExtend;} || {sustain valveInjectorOnOff;}
						 }
						 System.out.println("Canister returned");
					
						 canisterNum+=1 // switch to the next one.
						 pause;	 
					}
					send fillerStatus("done");
			}
		}
	}
}
		
		//if fillerReqs = true{
//		present(bottleAtPos2){ // if not send done ig
//			present(fillerReq){
//				present(selectCanister){
//					present (percentLiquid){
//						
//		//Given the assumption that the selected canister is externally rotated
//		// wait till the selected canister matches the orchestra.
//		present(selectCanister){
//			if (#selectCanister == #currentlySelectedCanister){// wait till canister match
//				// 
//				System.out.println("Canister match");
//				 abort(!dosUnitEvac){ // brings canister to the top
//						sustain dosUnitValveRetract;//
//				 }
//				 System.out.println("Canister above bottle");
//				 pause;
//				 
//				 abort(dosUnitFilled){ // close valve once filled
//					 sustain valveInletOnOff; 
//				 }
//				 System.out.println("Bottle controller filled");
//				 
//				 abort(dosUnitEvac){// bring cylinder to the bottom
//					 sustain dosUnitValveExtend;
//				 }
//				 System.out.println("Canister returned");
//				
//			}
//		}
//		}}}}
//				pause;
	}
	
}

Capper(
		
		//To and from Orchestrator
		input boolean channel capperReq;
		output String channel capperStatus;
		
		//From Capper Plant
		input signal bottleAtPos4;
		input signal gripperZAxisLowered;
		input signal gripperZAxisLifted;
		input signal gripperTurnHomePos;
		input signal gripperTurnFinalPos;
		input signal cylClampedBottle;
		input signal gripperGrippedCap;
		
		//To Capper Plant
		output signal cylPos5ZAxisExtend; //Brings the gripper down (absence of this signal will bring the gripper up)
		output signal gripperTurnRetract; //Untwists the gripper
		output signal gripperTurnExtend; //Twists the gripper
		output signal capGripperPos5Extend; //Grips the cap (absence of this signal will release the cap)
		output signal cylClampBottleExtend; //Clamps the bottle (absence of this signal will unclamp the bottle)
		)

		signal releaseCap, untwistGripper, raiseGripper, unclampBottle;

->{
	
	while(true) {
		
		receive capperReq; //Receive capper request.
		boolean request = (boolean) #capperReq;
		
		if (request) {
			send capperStatus("busy"); //Tell Orchestrator that Capper is processing its request.
			
			present (!bottleAtPos4) {
				send capperStatus("idle");
			}
			
			present(bottleAtPos4) { //Check if a bottle is at position 4, if not, wait until it arrives.
				
				{ 
					abort (unclampBottle) {
						sustain cylClampBottleExtend; //Keep gripping the bottle until steps 1-7 have completed (in-doc).
					}
				}
				||
				{
					abort(raiseGripper) {
						sustain cylPos5AxisExtend; //Keep the gripper lowered until steps 1-7 have completed.
					}
				}
				||
				{
					{await gripperZAxisLowered;} || {await gripperClampedBottle;}//Wait until gripper is lowered and bottle is clamped.
					abort(releaseCap) {
						sustain capGripperPos5Extend; //Grip the cap
					}
				}
				||
				{
					await gripperGrippedCap; //Wait until cap is gripped
					
					abort (gripperTurnFinalPos) {
						sustain gripperTurnExtend; // Twist the gripper
					}
					emit releaseCap; //Release the cap
					
					abort (gripperTurnHomePos) {
						emit untwistGripper; //Untwist gripper
					}
					
					emit raiseGripper; //Raise gripper
					emit unclampBottle; //Unclamp bottle
				}
			}
		}
		send capperStatus("done"); //Tell Orchestrator that the capper has finished.
		pause;
	}
}


Caploader(
		input signal pusherRetracted,pusherExtended,WPgripped,armAtSource,armAtDest,empty,request;
		output signal pusherExtend,vacOn,armSource,armDest;
		input Integer signal mode;
		input signal pusherExtendM,vacOnM,armSourceM,armDestM;
		)
->{
	while(true) {

			 // Automatic
				System.out.println("Automatic state");
				present (!empty){
					
					//Pusher extend
					present(pusherRetracted) { // every push tick
						abort(pusherExtended) { //plant emits when its at X
							sustain pusherExtend; // otherwise sustain
						}
					}
					pause;
					
					//Move arm to object to pickup
					abort(armAtSource) {
						sustain armSource;
					}
					pause;
					
					//Pickup Object
					abort(WPgripped){
						sustain vacOn;
					}
					pause;
					
					//return object to destination
					abort (armAtDest) {
						{sustain armDest;} || {sustain vacOn;}
					}
					pause;
		
					}
				pause;
			
	}
}